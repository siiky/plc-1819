%
% Layout retirado de http://www.di.uminho.pt/~prh/curplc09.html#notas
%
\documentclass{report}
\usepackage[portuges]{babel}
%\usepackage[utf8]{inputenc}
\usepackage[latin1]{inputenc}
\usepackage{url}
\usepackage{enumerate}

\usepackage{float} %package para introduzir a figura exactamente onde queremos no doc
\usepackage{graphicx} %package para utilizar imagens em latex
\graphicspath{ {images/} } %folder onde tem as imagens
\usepackage{wrapfig}
\usepackage{ tipa }
\usepackage{ textcomp }

%\usepackage{alltt}
%\usepackage{fancyvrb}
\usepackage{listings}
%LISTING - GENERAL
\lstset{
	language=C,
	basicstyle=\small,
	numbers=none,
	numberstyle=\tiny,
	numbersep=5pt,
	breaklines=true,
    frame=none,
	mathescape=true,
	escapeinside={(*@}{@*)}
}

%
%\lstset{ %
%	language=Java,							% choose the language of the code
%	basicstyle=\ttfamily\footnotesize,		% the size of the fonts that are used for the code
%	keywordstyle=\bfseries,					% set the keyword style
%	%numbers=left,							% where to put the line-numbers
%	numberstyle=\scriptsize,				% the size of the fonts that are used for the line-numbers
%	stepnumber=2,							% the step between two line-numbers. If it's 1 each line
%											% will be numbered
%	numbersep=5pt,							% how far the line-numbers are from the code
%	backgroundcolor=\color{white},			% choose the background color. You must add \usepackage{color}
%	showspaces=false,						% show spaces adding particular underscores
%	showstringspaces=false,					% underline spaces within strings
%	showtabs=false,							% show tabs within strings adding particular underscores
%	frame=none,								% adds a frame around the code
%	%abovecaptionskip=-.8em,
%	%belowcaptionskip=.7em,
%	tabsize=2,								% sets default tabsize to 2 spaces
%	captionpos=b,							% sets the caption-position to bottom
%	breaklines=true,						% sets automatic line breaking
%	breakatwhitespace=false,				% sets if automatic breaks should only happen at whitespace
%	title=\lstname,							% show the filename of files included with \lstinputlisting;
%											% also try caption instead of title
%	escapeinside={\%*}{*)},					% if you want to add a comment within your code
%	morekeywords={*,...}					% if you want to add more keywords to the set
%}

\usepackage{xspace}

\parindent=0pt
\parskip=2pt

\setlength{\oddsidemargin}{-1cm}
\setlength{\textwidth}{18cm}
\setlength{\headsep}{-1cm}
\setlength{\textheight}{23cm}



\def\LS{\textbf{\emph{LS}}}


%%%%\input{LPgeneralDefintions}

\title{Processamento de Linguagens e Compiladores\\\textbf{Gerador de Processadores de Linguagens Yacc}\\ Relatório de Desenvolvimento\\ Grupo 14}
\author{André Sá (76361) \and João Bastos (47419) \and Pedro Sá (78164)}
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
Este relatório debruça-se sobre o desenvolvimento de uma linguagem imperativa que com o auxilio do Yacc\footnote{Yacc - Gerador de Processadores de Linguagens} gera código Assembly, sendo este executável numa Máquina Virtual(VM)\footnote{Maquina Virtual que mostra o estado das várias stack's ao longo da execução do código gerado pelo Yacc em Assembly} fornecida pelo professor desta Unidade Curricular.  
\end{abstract}

\tableofcontents

\chapter{Introdução} \label{intro}
Este relatório debruça-se sobre o desenvolvimento de uma linguagem imperativa que com o auxilio do Yacc\footnote{Yacc - Gerador de Processadores de Linguagens} gera código Assembly, sendo este executável numa Máquina Virtual(VM)\footnote{Maquina Virtual que mostra o estado das várias stack's ao longo da execução do código gerado pelo Yacc em Assembly} fornecida pelo professor desta Unidade Curricular. 

\section{Enquadramento}
Um compilador é um programa que transforma um código fonte escrito numa determinada linguagem de alto nível noutra linguagem num nível inferior (mais próximo da linguagem máquina - código binário). Para tal o compilador irá passar pelas fases de análise léxica, sintáctica e semântica até produzir a linguagem final.

\section{Estrutura do Relatório}
Neste relatório começamos com a Introdução (Capítulo 1) onde, de uma forma breve tentamos descrever o enquadramento do documento e a estrutura do mesmo. \\
No capítulo 2 analisamos o texto a processar e o problema que nos foi proposto de forma mais detalhada bem como uma introdução da nossa abordagem ao mesmo.\\
No capítulo 3 indicamos a estrutura de dados utilizada e explicamos o código por nós criado.\\
No capítulo 4 apresentamos alguns testes realizados e o respectivo output.\\
O capítulo 5 é composto pela conclusão, onde fazemos uma análise ao projecto executado.\\
Por último o documento tem o apêndice onde foi introduzido o código fonte do ficheiro Yacc.


\chapter{Análise e Especificação}
\section{Descrição informal do problema}

Este projecto tem como objectivo o aprofundamento de conhecimento Yacc (um gerador de processadores de linguagens). Para tal, foi-nos proposto construir uma linguagem imperativa e gerar um compilador que transforma a sintaxe da linguagem para "Assembly" reconhecido pela máquina virtual fornecida pelo professor da Unidade Curricular.

\section{Especificação dos Requisitos\label{esp}}

A linguagem a criar deverá permitir declarar Variáveis atómicas dos tipos Inteiro, Real e Booleano e fazer Operações de Atribuição de Expressões a Variáveis declaradas, Leitura (de Inteiros ou Reais), Escrita (de Inteiros, Reais, Booleanos ou Strings), condições e ciclos repetir...até.
Após definir a linguagem deveremos a partir de um código fonte com essa linguagem transformar em código Assembly da Máquina Virtual fornecida para o efeito.


\chapter{Linguagem Imperativa}
Neste capítulo explicaremos a linguagem imperativa definida e a sua sintaxe.

\section{Tipos}
Apresentamos os tipos aceites na linguagem criada.\\

\begin{tabular}{r l l}
\textbf{Tipo} & \textbf{Descrição} & \textbf{Exemplos} \\
\hline
\textbf{Int} & Inteiro & 1 -22 35 \\
\textbf{Float} & Reais & 1.333 3.0E10 \\
\textbf{Bool} & Booleano & True False \\
\end{tabular}

\section{Operadores}
Os operadores dividem-se em 3 tipos: aritméticos, relacionais e lógicos. De seguida apresentamos os operadores utilizados e a correspondente descrição.
\\

\begin{tabular}[t]{p{30mm} c c l}
\textbf{ARITMÉTICOS} & & \textbf{Operador} & \textbf{Descrição} \\  \cline{3-4}
 &  & \textbf{+} & Soma \\
 &  & \textbf{-} & Subtração \\
 &  & \textbf{*} & Multiplicação\\
 &  & \textbf{/} & Divisão \\
 &  & \textbf{\%} & Resto da divisão inteira \\
\end{tabular}

\mbox{}\\

\begin{tabular}[t]{p{30mm} c c l}
\textbf{RELACIONAIS} & & \textbf{Operador} & \textbf{Descrição}\\ \cline{3-4}
 &  & \textbf{\textless} & Menor \\
 &  & \textbf{\textgreater} & Maior \\
 &  & \textbf{=} & Igual \\
 &  & \textbf{\textless=} & Menor ou igual \\
 &  & \textbf{\textgreater=} & Maior ou igual \\
 &  & \textbf{!=} & Diferente \\
\end{tabular}

\mbox{}\\

\begin{tabular}[t]{p{30mm} c c l}
\textbf{LÓGICOS} & & \textbf{Operador} & \textbf{Descrição}\\ \cline{3-4}
 &  & \textbf{\&} & E lógico \\
 &  & \textbf{\textpipe} & OU lógico \\
 &  & \textbf{\texttildelow} & Negação\\
\end{tabular}


\section{Declaração de Variáveis}
A declaração de variáveis tem a seguinte sintaxe:\\

\fbox{\textbf{(:} tipo var\textbf{)} }\\

Ao declarar, as variáveis são iniciadas com o valor pré-definido do tipo em questão:\\
 
\begin{tabular}{r l}
\textbf{Tipo} & \textbf{Default} \\
\hline
\textbf{Int} & 0\\
\textbf{Float} & 0.0 \\
\textbf{Bool} & False \\
\end{tabular}\\\\

No entanto também é possível definir no momento um \emph{default} diferente iniciando-a com o valor, do tipo da variável, definido. Nestes casos utilizamos a seguinte sintaxe:\\

\fbox{\textbf{(:} tipo var default\textbf{)}}\\

Só é permitido declarar variáveis (\emph{var}) do \emph{tipo} Int, Float e Bool.\\

\section{Atribuições}
Na atribuição de valores (\emph{valor}) a variáveis (\emph{var}) temos a sintaxe seguinte:\\

\fbox{\textbf{(=} var valor \textbf{)}}\\
\\

Podemos também incrementar numa unidade o valor da variável (\emph{var}):\\

\fbox{\textbf{(++} var valor\textbf{)}}\\


\section{Condições}

\fbox{\textbf{(if} exp \textbf{(}code\_block\textbf{) [ (}else\_code\_block\textbf{) ] )}} \\

\section{Ciclos}

\fbox{\textbf{(until} exp \textbf{(}code\_block\textbf{) )}} \\

\section{Leitura}

\fbox{\textbf{(read} var\textbf{)}}\\

          	  	
\section{Escrita}

\fbox{\textbf{(write} texto\textbf{)}}\\

\section{Impressão}

\fbox{\textbf{(print} texto\textbf{)}}\\

\chapter{Concepção/desenho da Resolução}

\chapter{Testes}
\section{Testes realizados e Resultados}

Para efeitos de teste preparamos vários ficheiros que cada um contém desde declarações, a atribuições, condições, ciclos, etc...\\
Estes testes serão organizados em tabeas abaixo apresentadas com a primeira coluna a representar o código-fonte de acordo com a nossa linguagem imperativa criada e a segunda coluna o código em "assembly" em conformidada com a máquina virtual fornecida.
\subsection{Declarações e Atribuições}
\begin{tabular}{ | c |c|}
\hline
Input & Output \\
\hline
\lstinputlisting{../examples/atribs.z}
 & \lstinputlisting{../examples/atribs.vm} \\
 \hline
\end{tabular}

\subsection{Operadores Aritméticos}
\begin{tabular}{| c |c|}
\hline
Input & Output \\
\hline

\lstinputlisting{../examples/arith.z}
& \lstinputlisting{../examples/arith.vm} \\
\hline
\end{tabular}

\subsection{Leitura}
\begin{tabular}{| c |c|}
\hline
Input & Output \\
\hline
\lstinputlisting{../examples/read_float.z}
 & \lstinputlisting{../examples/read_float.vm}\\
\hline
\end{tabular}


\subsection{Condição IF}
\begin{tabular}{| c |c|}
\hline
Input & Output \\
\hline
\lstinputlisting{../examples/if.z}
 & \lstinputlisting{../examples/if.vm}\\
\hline
\end{tabular}

\subsection{Ciclo Repetir..Até }
\begin{tabular}{| c |c|}
\hline
Input & Output \\
\hline
\lstinputlisting{../examples/until.z}
 & \lstinputlisting{../examples/until.vm}\\
\hline
\end{tabular}

\chapter{Conclusão} \label{concl}
Este projecto mostrou-nos que tendo já desenvolvido a gramática de uma linguagem imperativa, podemos criar um compilador através do Yacc que usando a estrutura 'Produção-Ação', isto é, para cada instrução do código fonte que satisfaça alguma produção da linguagem imperativa tem como ação a criação do código "assembly", o que consequentemente, deu-nos uma visão mais detalhada sobre como um compilador funciona.
Este projeto está finalizado para o que nos foi proposto.

\appendix
\chapter{Código do Programa}


Lista-se a seguir o código Yacc do programa que foi desenvolvido.
\begin{verbatim}
%{
#include <stdbool.h>
#include <stdio.h>

#include "env.h"
#include "gen.h"
#include "str.h"
#include "rope.h"

#include "lex.yy.h"

int yyerror (const char *s);

/**
 * Verifica se uma condicao e verdadeira e, caso nao seja,
 * imprime uma mensagem de erro e aborta o programa
 */
#define assert(cond, ...)                       \
    if (!(cond)) do {                           \
        fprintf(stderr, "ERROR: " __VA_ARGS__); \
        return 1;                               \
    } while (0)

/** Se activado, mostra as producoes por onde passa */
#ifdef TRACE
#define trace(...) ((void) fprintf(stderr, "TRACE: %s:%d\n", __FILE__, __LINE__))
#else
#define trace(...) ((void) 0)
#endif /* TRACE */

#define type_valid(t)       ((t) > TYPE_ERROR && (t) < TYPE_DEFAULT)
#define type_compat(t1, t2) ((t1) == (t2))

/**
 * Concatena dois blocos de codigo, @a self e @a other, e imprime
 * uma mensagem em caso de erro
 */
#define cbapp(self, other) do {                \
        assert(rope_append(&(self), &(other)), \
            "appending code blocks: %s:%d\n",  \
            __FILE__, __LINE__);               \
        (other) = rope_free(other);            \
    } while (0)

/**
 * Gera wrappers para funcoes geradoras de codigo que imprimem
 * uma mensagem em caso de erro
 */
#define gen_(f, ...)               \
    assert((gen_##f)(__VA_ARGS__), \
        #f "(): %s:%d\n",          \
        __FILE__, __LINE__)

#define gen_jump(  c, l, n)    gen_(jump,   (c), (l), (n))
#define gen_jz(    c, l, n)    gen_(jz,     (c), (l), (n))
#define gen_nlbl(  c, l, n)    gen_(nlbl,   (c), (l), (n))
#define gen_load(  c, i)       gen_(load,   (c), (i))
#define gen_op(    c, o, t)    gen_(op,     (c), (o), (t))
#define gen_push(  c, t, a, b) gen_(push,   (c), (t), (a), (b))
#define gen_pushgp(c)          gen_(pushgp, (c))
#define gen_storeg(c, i)       gen_(storeg, (c), (i))

static struct rope _var_decs = {0};
static struct rope * const var_decs = &_var_decs;

%}

%union {
    struct expr {
        enum type   type;
        struct rope code;
    }           valExpr;

    bool        valBool;
    char *      valString;
    enum type   valType;
    float       valFloat;
    int         valInt;
    struct rope valCode;
}

%token INC
%token GEQ
%token IF
%token LEQ
%token NEQ
%token PRINT
%token READ
%token UNTIL
%token WRITE

%token <valBool>  BOOL_VALUE
%token <valFloat> FLOAT_VALUE
%token <valInt>   INT_VALUE
%token <valString>STR
%token <valString>VAR
%token <valType>  TYPE

%type <valCode>code_block
%type <valCode>else_clause
%type <valCode>statement
%type <valCode>statements

%type <valExpr>DEFAULT
%type <valExpr>expression
%type <valExpr>expression2
%type <valExpr>expression2_list
%type <valExpr>expression_list
%type <valExpr>writable

%type <valInt>arith_op
%type <valInt>log_op
%type <valInt>num_op

%type <valType>VALUE

%%

programa : code_block { trace();
             rope_fprint(var_decs, yyout);
             fputs("START\n", yyout);
             rope_fprint(&$1, yyout);
             fputs("STOP\n", yyout);
             $1 = rope_free($1);
         }
         ;

code_block : statements            { trace(); $$ = $1; }
           | statements code_block { trace();
               $$ = $1;
               cbapp($$, $2);
           }
           ;

statements : '(' statement ')' { trace(); $$ = $2; }
           ;

statement : ':' TYPE VAR DEFAULT { trace();
              assert($4.type != TYPE_ERROR
                  && (!type_valid($4.type) || type_compat($2, $4.type)),
                  "%s:%s but default value is of type %s\n",
                  $3, type2str($2), type2str($4.type));

              struct var var = { .id = $3, .type = $2, };
              assert(env_new_var(env, var), "creating variable `%s`\n", $3);

              $$ = $4.code;
              if (!rope_is_empty(&$$))
                  gen_storeg(&$$, env_var_gp_idx(env, $3));

              gen_push(var_decs, $2,
                  (($2 == TYPE_FLOAT) ? "0.0" : "0"),
                  yylval.valBool);
          }
          | INC VAR { trace();
              $$ = (struct rope) {0};
              struct var * v = env_var(env, $2);
              enum type t = env_typeof(env, $2);
              unsigned gidx = env_var_gp_idx(env, $2);

              assert(v != NULL, "Variable not found: `%s`\n", $2);

              assert(t == TYPE_INT || t == TYPE_FLOAT,
                  "type: Expected Int or Float but got %s\n",
                  type2str(t));

              const char * arg = (t == TYPE_INT) ? "1" : "1.0";

              gen_pushgp(&$$);
              gen_load(&$$, gidx);
              gen_push(&$$, t, arg, false);
              gen_op(&$$, '+', t);
              gen_storeg(&$$, gidx);
          }
          | '=' VAR expression { trace();
              struct var * v = env_var(env, $2);
              assert(v != NULL, "Variable not found: `%s`\n", $2);
              $$ = $3.code;
              gen_storeg(&$$, env_var_gp_idx(env, $2));
          }
          | WRITE writable { trace();
              $$ = $2.code;
              gen_op(&$$, WRITE, $2.type);
          }
          | PRINT writable { trace();
              $$ = $2.code;
              gen_op(&$$, WRITE, $2.type);
              gen_push(&$$, TYPE_STRING, "\"\\n\"", false);
              gen_op(&$$, WRITE, TYPE_STRING);
          }
          | READ VAR { trace();
              $$ = (struct rope) {0};
              struct var * v = env_var(env, $2);
              assert(v != NULL, "Variable not found: `%s`\n", $2);

              assert(v->type == TYPE_INT || v->type == TYPE_FLOAT,
                  "`read`: Expected Int or Float but got %s\n",
                  type2str(v->type));

              gen_read(&$$);
              gen_aton(&$$, v->type);
              gen_storeg(&$$, env_var_gp_idx(env, $2));
          }
          | IF expression2 '(' code_block ')' else_clause { trace();
              unsigned num = gen_ifno();

              $$ = $2.code;
              gen_jz(&$$, "ELSE", num);    /* jump to else label? */
              cbapp($$, $4);               /* then block */
              gen_jump(&$$, "ENDIF", num); /* jump to endif label */
              gen_nlbl(&$$, "ELSE", num);  /* else label */
              cbapp($$, $6);               /* else block (possibly empty) */
              gen_nlbl(&$$, "ENDIF", num); /* endif label */
          }
          | UNTIL expression2 '(' code_block ')' { trace();
              $$ = (struct rope) {0};
              unsigned num = gen_untilno();

              gen_nlbl(&$$, "UNTIL", num); /* until label */
              cbapp($$, $4);               /* loop body block */
              cbapp($$, $2.code);          /* condition */
              gen_jz(&$$, "UNTIL", num);   /* jump to until label? */
          }
          ;

writable : expression { trace(); $$ = $1; }
         | STR        { trace();
             $$ = (struct expr) {0};
             $$.type = TYPE_STRING;
             gen_push(&$$.code, TYPE_STRING, yytext, false);
         }
         ;

DEFAULT : { trace();
            $$ = (struct expr) {0};
            $$.type = TYPE_DEFAULT;
        }
        | expression { trace(); $$ = $1; }
        ;

else_clause :                    { trace(); $$ = (struct rope) {0}; }
            | '(' code_block ')' { trace(); $$ = $2; }
            ;

expression : VALUE { trace();
               $$ = (struct expr) {0};
               $$.type = $1;
               gen_push(&$$.code, $1, yytext, false);
           }
           | expression2             { trace(); $$ = $1; }
           | '(' expression_list ')' { trace(); $$ = $2; }
           ;

VALUE : INT_VALUE   { trace(); $$ = TYPE_INT;   }
      | FLOAT_VALUE { trace(); $$ = TYPE_FLOAT; }
      ;

arith_op : '+' { trace(); $$ = '+'; }
         | '*' { trace(); $$ = '*'; }
         | '-' { trace(); $$ = '-'; }
         | '/' { trace(); $$ = '/'; }
         | '%' { trace(); $$ = '%'; }
         ;

expression_list : arith_op expression expression { trace();
                    $$ = (struct expr) {0};
                    enum type t1 = $2.type;
                    enum type t2 = $3.type;
                    assert(type_valid(t1) && type_valid(t2) && type_compat(t1, t2),
                        "`%c`: Types don't match: op1:%s and op2:%s\n",
                        $1, type2str(t1), type2str(t2));
                    $$.type = t1;

                    assert($$.type != TYPE_FLOAT || $1 != '%',
                        "`%%`: Expected Int, got %s\n",
                        type2str($$.type));

                    $$.code = $2.code;
                    cbapp($$.code, $3.code);
                    gen_op(&$$.code, $1, t1);
                }
                ;

expression2 : VAR { trace();
                $$ = (struct expr) {0};
                $$.type = env_typeof(env, $1);
                assert(type_valid($$.type), "Variable not found: `%s`\n", $1);

                gen_pushgp(&$$.code);
                gen_load(&$$.code, env_var_gp_idx(env, $1));
            }
            | BOOL_VALUE { trace();
                $$ = (struct expr) {0};
                $$.type = TYPE_BOOL;
                gen_push(&$$.code, TYPE_BOOL, NULL, yylval.valBool);
            }
            | '(' expression2_list ')' { trace(); $$ = $2; }
            ;

num_op : '<' { trace(); $$ = '<'; }
       | '=' { trace(); $$ = '='; }
       | '>' { trace(); $$ = '>'; }
       | GEQ { trace(); $$ = GEQ; }
       | LEQ { trace(); $$ = LEQ; }
       | NEQ { trace(); $$ = NEQ; }
       ;

log_op : '&' { trace(); $$ = '&'; }
       | '|' { trace(); $$ = '|'; }
       ;

expression2_list : '~' expression2 { trace();
                     $$ = (struct expr) {0};
                     enum type t = $2.type;
                     assert(t == TYPE_BOOL, "`~`: Expected Bool, got %s\n", type2str(t));
                     $$.type = t;

                     $$.code = $2.code;

                     gen_op(&$$.code, '~', $2.type);
                 }
                 | num_op expression expression { trace();
                     $$ = (struct expr) {0};
                     enum type t1 = $2.type;
                     enum type t2 = $3.type;
                     assert(type_valid(t1) && type_valid(t2) && type_compat(t1, t2),
                         "`%c`: Types don't match: op1:%s and op2:%s\n",
                         $1, type2str(t1), type2str(t2));
                     $$.type = TYPE_BOOL;

                     $$.code = $2.code;
                     cbapp($$.code, $3.code);
                     gen_op(&$$.code, $1, t1);
                 }
                 | log_op expression2 expression2 { trace();
                     enum type t1 = $2.type;
                     enum type t2 = $3.type;
                     assert(t1 == TYPE_BOOL && t2 == TYPE_BOOL,
                         "`%c`: Expected Bool, got op1:%s and op2:%s\n",
                         $1, type2str(t1), type2str(t2));

                     $$ = $2;

                     cbapp($$.code, $3.code);
                     gen_op(&$$.code, $1, t1);
                 }
                 ;

%%

int yyerror (const char *s)
{
  return fprintf(stderr, "ERRO: '%s'\n", s);
}
\end{verbatim}

\end{document} 
