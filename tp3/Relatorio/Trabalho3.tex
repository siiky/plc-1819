%
% Layout retirado de http://www.di.uminho.pt/~prh/curplc09.html#notas
%
\documentclass{report}
\usepackage[portuges]{babel}
%\usepackage[utf8]{inputenc}
\usepackage[latin1]{inputenc}
\usepackage{url}
\usepackage{enumerate}

\usepackage{float} %package para introduzir a figura exactamente onde queremos no doc
\usepackage{graphicx} %package para utilizar imagens em latex
\graphicspath{ {images/} } %folder onde tem as imagens
\usepackage{wrapfig}
\usepackage{ tipa }
\usepackage{ textcomp }

%\usepackage{alltt}
%\usepackage{fancyvrb}
\usepackage{listings}
%LISTING - GENERAL
\lstset{
	language=C,
	basicstyle=\small,
	numbers=left,
	numberstyle=\tiny,
	numbersep=5pt,
	breaklines=true,
    frame=tB,
	mathescape=true,
	escapeinside={(*@}{@*)}
}

%
%\lstset{ %
%	language=Java,							% choose the language of the code
%	basicstyle=\ttfamily\footnotesize,		% the size of the fonts that are used for the code
%	keywordstyle=\bfseries,					% set the keyword style
%	%numbers=left,							% where to put the line-numbers
%	numberstyle=\scriptsize,				% the size of the fonts that are used for the line-numbers
%	stepnumber=2,							% the step between two line-numbers. If it's 1 each line
%											% will be numbered
%	numbersep=5pt,							% how far the line-numbers are from the code
%	backgroundcolor=\color{white},			% choose the background color. You must add \usepackage{color}
%	showspaces=false,						% show spaces adding particular underscores
%	showstringspaces=false,					% underline spaces within strings
%	showtabs=false,							% show tabs within strings adding particular underscores
%	frame=none,								% adds a frame around the code
%	%abovecaptionskip=-.8em,
%	%belowcaptionskip=.7em,
%	tabsize=2,								% sets default tabsize to 2 spaces
%	captionpos=b,							% sets the caption-position to bottom
%	breaklines=true,						% sets automatic line breaking
%	breakatwhitespace=false,				% sets if automatic breaks should only happen at whitespace
%	title=\lstname,							% show the filename of files included with \lstinputlisting;
%											% also try caption instead of title
%	escapeinside={\%*}{*)},					% if you want to add a comment within your code
%	morekeywords={*,...}					% if you want to add more keywords to the set
%}

\usepackage{xspace}

\parindent=0pt
\parskip=2pt

\setlength{\oddsidemargin}{-1cm}
\setlength{\textwidth}{18cm}
\setlength{\headsep}{-1cm}
\setlength{\textheight}{23cm}



\def\LS{\textbf{\emph{LS}}}


%%%%\input{LPgeneralDefintions}

\title{Processamento de Linguagens e Compiladores\\\textbf{Gerador de Processadores de Linguagens Yacc}\\ Relatório de Desenvolvimento\\ Grupo 14}
\author{André Sá (76361) \and João Bastos (47419) \and Pedro Sá (78164)}
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
Este relatório debruça-se sobre o desenvolvimento de uma linguagem imperativa que com o auxilio do Yacc\footnote{Yacc - Gerador de Processadores de Linguagens} gera código Assembly, sendo este executável numa Máquina Virtual(VM)\footnote{Maquina Virtual que mostra o estado das várias stack's ao longo da execução do código gerado pelo Yacc em Assembly} fornecida pelo professor desta Unidade Curricular.  
\end{abstract}

\tableofcontents

\chapter{Introdução} \label{intro}
Este relatório debruça-se sobre o desenvolvimento de uma linguagem imperativa que com o auxilio do Yacc\footnote{Yacc - Gerador de Processadores de Linguagens} gera código Assembly, sendo este executável numa Máquina Virtual(VM)\footnote{Maquina Virtual que mostra o estado das várias stack's ao longo da execução do código gerado pelo Yacc em Assembly} fornecida pelo professor desta Unidade Curricular. 

\section{Enquadramento}
Um compilador é um programa que transforma um código fonte escrito numa determinada linguagem de alto nível noutra linguagem num nível inferior (mais próximo da linguagem máquina - código binário). Para tal o compilador irá passar pelas fases de análise léxica, sintáctica e semântica até produzir a linguagem final.

\section{Estrutura do Relatório}
Neste relatório começamos com a Introdução (Capítulo 1) onde, de uma forma breve tentamos descrever o enquadramento do documento e a estrutura do mesmo. \\
No capítulo 2 analisamos o texto a processar e o problema que nos foi proposto de forma mais detalhada bem como uma introdução da nossa abordagem ao mesmo.\\
No capítulo 3 indicamos a estrutura de dados utilizada e explicamos o código por nós criado.\\
No capítulo 4 apresentamos alguns testes realizados e o respectivo output.\\
O capítulo 5 é composto pela conclusão, onde fazemos uma análise ao projecto executado.\\
Por último o documento tem o apêndice onde foi introduzido o código fonte do ficheiro Yacc.


\chapter{Análise e Especificação}
\section{Descrição informal do problema}

Este projecto tem como objectivo o aprofundamento de conhecimento do Sistema de Produção\footnote{Sistema baseado num conjunto de regras 'Condição-Acção'.} AWK (uma lingagem de programação para a deteção de padrões e processamento de texto, mais o respetivo interpretador). Para tal, foi-nos proposto construir um ficheiro Gawk\footnote{Gawk - GNU AWK (A palavra AWK é uma abreviatura das iniciais dos sobrenomes dos criadores da linguagem (Aho, Weinberger e Kernighan).} para processar um rol de confessados, com o intuito de calcular o número de certas ocorrências.\\
Na próxima secção indicaremos com mais detalhe as ocorrências pretendidas e de que forma pretendemos resolver tais problemas.

\section{Especificação dos Requisitos\label{esp}}

A linguagem a criar deverá permitir declarar Variáveis atómicas dos tipos Inteiro, Real e Booleano e fazer Operações de Atribuição de Expressões a Variáveis declaradas, Leitura (de Inteiros ou Reais), Escrita (de Inteiros, Reais, Booleanos ou Strings), condições e ciclos repetir .. até.
Após definir a linguagem deveremos a partir de um código fonte com essa linguagem transformar em código Assembly da Máquina Virtual fornecida para o efeito.


\chapter{Linguagem Imperativa}
Neste capítulo explicaremos a linguagem imperativa definida e a sua sintaxe.

\section{Tipos}
Apresentamos os tipos aceites na linguagem criada.\\

\begin{tabular}{r l l}
\textbf{Tipo} & \textbf{Descrição} & \textbf{Exemplos} \\
\hline
\textbf{Int} & Inteiro & 1 -22 35 \\
\textbf{Float} & Reais & 1.333 3.0E10 \\
\textbf{Bool} & Booleano & True False \\
\end{tabular}

\section{Operadores}
Os operadores dividem-se em 3 tipos: aritméticos, relacionais e lógicos. De seguida apresentamos os operadores utilizados e a correspondente descrição.
\\

\begin{tabular}[t]{p{30mm} c c l}
\textbf{ARITMÉTICOS} & & \textbf{Operador} & \textbf{Descrição} \\  \cline{3-4}
 &  & \textbf{+} & Soma \\
 &  & \textbf{-} & Subtração \\
 &  & \textbf{*} & Multiplicação\\
 &  & \textbf{/} & Divisão \\
 &  & \textbf{\%} & Resto da divisão inteira \\
\end{tabular}

\mbox{}\\

\begin{tabular}[t]{p{30mm} c c l}
\textbf{RELACIONAIS} & & \textbf{Operador} & \textbf{Descrição}\\ \cline{3-4}
 &  & \textbf{\textless} & Menor \\
 &  & \textbf{\textgreater} & Maior \\
 &  & \textbf{=} & Igual \\
 &  & \textbf{\textless=} & Menor ou igual \\
 &  & \textbf{\textgreater=} & Maior ou igual \\
 &  & \textbf{!=} & Diferente \\
\end{tabular}

\mbox{}\\

\begin{tabular}[t]{p{30mm} c c l}
\textbf{LÓGICOS} & & \textbf{Operador} & \textbf{Descrição}\\ \cline{3-4}
 &  & \textbf{\&} & E lógico \\
 &  & \textbf{\textpipe} & OU lógico \\
 &  & \textbf{\texttildelow} & Negação\\
\end{tabular}


\section{Declaração de Variáveis}
A declaração de variáveis tem a seguinte sintaxe:\\

\fbox{\textbf{(:} tipo var\textbf{)} }\\

Ao declarar, as variáveis são iniciadas com o valor pré-definido do tipo em questão:\\
 
\begin{tabular}{r l}
\textbf{Tipo} & \textbf{Default} \\
\hline
\textbf{Int} & 0\\
\textbf{Float} & 0.0 \\
\textbf{Bool} & False \\
\end{tabular}\\\\

No entanto também é possível definir no momento um \emph{default} diferente iniciando-a com o valor, do tipo da variável, definido. Nestes casos utilizamos a seguinte sintaxe:\\

\fbox{\textbf{(:} tipo var default\textbf{)}}\\

Só é permitido declarar variáveis (\emph{var}) do \emph{tipo} Int, Float e Bool.\\

\section{Atribuições}
Na atribuição de valores (\emph{valor}) a variáveis (\emph{var}) temos a sintaxe seguinte:\\

\fbox{\textbf{(=} var valor \textbf{)}}\\
\\

Podemos também incrementar numa unidade o valor da variável (\emph{var}):\\

\fbox{\textbf{(++} var valor\textbf{)}}\\


\section{Condições}

\fbox{\textbf{(if} exp \textbf{(}code\_block\textbf{) [ (}else\_code\_block\textbf{) ] )}} \\

\section{Ciclos}

\fbox{\textbf{(until} exp \textbf{(}code\_block\textbf{) )}} \\

\section{Leitura}

\fbox{\textbf{(read} var\textbf{)}}\\

          	  	
\section{Escrita}

\fbox{\textbf{(write} texto\textbf{)}}\\

\section{Impressão}

\fbox{\textbf{(print} texto\textbf{)}}\\

\chapter{Concepção/desenho da Resolução}





\section{Estruturas de Dados}

Um array associativo é uma estrutura de dados - análoga aos dicionários - composta por um conjunto não ordenado de itens formados por um par chave-valor, em que cada chave possui um valor associado. \\
O Gawk permite-nos utilizar strings como índices. Assim, optamos pela utilização de arrays associativos para contar a ocorrência de determinadas strings sendo as strings as chaves e o valor o número de ocorrências de cada uma.

\section{Codificação}

\subsubsection{BEGIN}
Inicialmente especificamos acções a serem executadas antes do processamento da primeira linha utilizando o padrão BEGIN.
\begin{verbatim}
BEGIN   {
            FS="::";
            IGNORECASE=1
        }
\end{verbatim}
Assim definimos o Field Separator (FS) como "::" \ e a detecção de padrões como Case Insensitive.

\subsubsection{Linhas em Branco}
Salvaguardamos o facto do ficheiro ter linhas em branco ignorando as mesmas.
\begin{verbatim}
/^\s*$/	{ next; } 
\end{verbatim}

\subsubsection{Alínea a) - Frequência de processos por ano}
Para calcularmos o número de processos por ano separamos o que está entre '-' no 1º campo e, num array associativo, utilizamos o elemento correspondente ao ano\footnote{Formato do 1º campo: 1778-01-14. Ter em conta que em Awk os índices dos arrays sendo numéricos começam em 1, que é o índice onde será guardado o ano no array data.} como chave. Se a chave já existe apenas incrementa, caso contrário cria a nova chave e incrementa o valor.
\begin{verbatim}
		{
    			split($2, data, /-/);
    			alA[data[1]]++;
		}
\end{verbatim}

\subsubsection{Alínea b) - Frequência de nomes}
Os nomes que pretendemos vão estar todos entre os campos 3, 4 e 5, que correspondem respectivamente ao paroquiano, o seu pai e a sua mãe. Nos campos indicados estão os nomes completos mas, uma vez que pretendemos contar as ocorrências de cada nome, separamos os vários nomes e apelidos e guardamos num array associativo. Cada nome/apelido será a chave desse array e a cada ocorrência irá incrementar o respectivo valor. Assim, no final do processamento de todas as linhas do texto teremos guardado nesse array todos os nomes/apelidos (chave) e o número de ocorrências de cada um deles (valor).

\begin{verbatim}
{
    for (i = 3; i < 6; i++) {
        # Tirar Expostos/Solteiras/etc
        gsub(/,.*$/, "", $i);

        split($i, nomes, /\s+/);

        for (nome in nomes)
            alB[nomes[nome]]++;
    }
}
\end{verbatim}


\subsubsection{Alínea c) - Frequência dos tipos de relação}
Analisando o rol de confessados que nos foi facultado verificamos que dentro do 6º campo temos informação complementar onde, entre outras informações, surgem os tipos de relação. Portanto procuramos correspondências com os padrões dentro do 6º campo de cada linha.
Verificamos também que cada relação identificada é precedida de uma virgula e termina com o ponto final. Assim, optamos pela procura desse padrão associando a correspondência à chave do array associativo incrementando o seu valor a cada correspondência obtida.


\begin{verbatim}

$6 ~ /,\<avo\>([ ]+[mp]atern[oa]s?)?\./        { alC["avo"]++; }
$6 ~ /,\<irmaos?\>([ ]+[mp]atern[oa]s?)?\./    { alC["irmao"]++; }
$6 ~ /,\<irmas?\>([ ]+[mp]atern[oa]s?)?\./     { alC["irma"]++; }
$6 ~ /,\<mae\>\./                              { alC["mae"]++; }
$6 ~ /,\<madrastas?\>([ ]+[mp]atern[oa]s?)?\./ { alC["madrasta"]++; }
$6 ~ /,\<padrastos?\>([ ]+[mp]atern[oa]s?)?\./ { alC["padrasto"]++; }
$6 ~ /,\<madrinhas?\>([ ]+[mp]atern[oa]s?)?\./ { alC["madrinha"]++; }
$6 ~ /,\<padrinhos?\>([ ]+[mp]atern[oa]s?)?\./ { alC["padrinho"]++; }
$6 ~ /,\<pai\>\./                              { alC["pai"]++; }
$6 ~ /,\<primas?\>([ ]+[mp]atern[oa]s?)?\./    { alC["prima"]++; }
$6 ~ /,\<primos?\>([ ]+[mp]atern[oa]s?)?\./    { alC["primo"]++; }
$6 ~ /,\<sobrinhas?\>([ ]+[mp]atern[oa]s?)?\./ { alC["sobrinha"]++; }
$6 ~ /,\<sobrinhos?\>([ ]+[mp]atern[oa]s?)?\./ { alC["sobrinho"]++; }
$6 ~ /,\<tias?\>([ ]+[mp]atern[oa]s?)?\./      { alC["tia"]++; }
$6 ~ /,\<tios?\>([ ]+[mp]atern[oa]s?)?\./      { alC["tio"]++; }
\end{verbatim}

\subsubsection{Funções}
Definimos 3 funções que irão escrever o conteúdo de cada um dos arrays associativos - cada um no seu ficheiro - de forma formatada e com uma descrição na primeira linha de cada um.
\begin{verbatim}
function alineaA (outf)
{
    printf "Frequência de processos por ano:\n" > outf;
    for (ano in alA)
        printf("%s\t%s\n", ano, alA[ano]) >> outf;
}

function alineaB (outf)
{
    printf "Frequência de nomes:\n" > outf;
    for (nome in alB)
        printf("%s\t%s\n", nome, alB[nome]) >> outf;
}

function alineaC (outf)
{
    printf "Frequência dos vários tipos de relação:\n" > outf;
    for (parentesco in alC)
        printf("%s\t%s\n", parentesco, alC[parentesco]) >> outf;
}
\end{verbatim}
 
 
\subsubsection{END}

Para finalizar utilizamos o END para executarmos as funções acima definidas após todas as linhas terem sido executadas. 

\begin{verbatim}
END     {
          alineaA("anos.txt");
          alineaB("nomes.txt");
          alineaC("parentescos.txt");
        }	
\end{verbatim}
Criando assim os 3 ficheiros com extensão txt que irão armazenar os resultados pedidos para cada uma das alíneas.

\chapter{Testes}
\section{Testes realizados e Resultados}

Devido ao facto do rol de confessados ter bastante informação para ser processada ($\approx 37000\ linhas$), o grupo decidiu para efeitos de apresentação de testes e resultados desse processamento, apresentar neste relatório uma porção do rol de confessados representativa da informação contida nesse rol.\\
Ao processar o rol de confessados verificamos que existem algumas variações na apresentação da informação, isto é, existem registos (linhas do rol de confessados) em que os campos não estavam todos preenchidos, mais especificamente o campo 6. E por vezes, como foi referido na secção \ref{esp}, esse campo contém informação complementar incluindo tipo de relação.\\
Abaixo encontra-se porção supra referida do rol de processos, onde cada linha representa um registo desse rol e contém os campos referidos na secção \ref{esp}.
\\


%\lstinputlisting{../teste1.txt} %input de um ficheiro

\subsubsection{Alínea a) - Frequência de processos por ano}
De seguida apresentamos o ficheiro \emph{anos.txt} com o resultado da frequência de processos por ano:\\

%\lstinputlisting{../anos.txt} %input de um ficheiro

\subsubsection{Alínea b) - Frequência de nomes}
De seguida apresentamos o ficheiro \emph{nomes.txt} com o resultado da frequência de nomes:\\
%\lstinputlisting{../nomes.txt} %input de um ficheiro

\subsubsection{Alínea c) - Frequência dos tipos de relação}
De seguida apresentamos o ficheiro \emph{parentescos.txt} com o resultado da frequência de vários tipos de relação:\\
%\lstinputlisting{../parentescos.txt} %input de um ficheiro



\chapter{Conclusão} \label{concl}

Este projecto mostrou-nos que o Gawk permite-nos programar filtros de texto e relatórios sobre informação de forma muito acessível, principalmente quando existe muito informação para ser processada.\\
Este projeto está finalizado para o que nos foi proposto.
Se no futuro houver necessidade de uma filtragem/processamento mais específico apenas teremos de fazer pequenas alterações ou incluir novos padrões baseando-nos na mesma estrutura 'Padrão-Acção' e usando a mesma estrutura de dados (arrays associativos).

\appendix
\chapter{Código do Programa}

Lista-se a seguir o código Awk do programa  que foi desenvolvido.
\begin{verbatim}
BEGIN {
    FS="::";
    IGNORECASE=1
}

/^\s*$/ { next; }

{ # Alinea (a)
    split($2, data, /-/);
    alA[data[1]]++;
}

{ # Alinea (b)
    for (i = 3; i < 6; i++) {
        # Tirar Expostos/Solteiras/etc
        gsub(/,.*$/, "", $i);

        split($i, nomes, /\s+/);

        for (nome in nomes)
            alB[nomes[nome]]++;
    }
}

# Alinea (c)
$6 ~ /,\<avo\>([ ]+[mp]atern[oa]s?)?\./        { alC["avo"]++; }
$6 ~ /,\<irmaos?\>\./                          { alC["irmao"]++; }
$6 ~ /,\<irmas?\>\./                           { alC["irma"]++; }
$6 ~ /,\<mae\>\./                              { alC["mae"]++; }
$6 ~ /,\<madrastas?\>\./                       { alC["madrasta"]++; }
$6 ~ /,\<padrastos?\>\./                       { alC["padrasto"]++; }
$6 ~ /,\<madrinhas?\>\./                       { alC["madrinha"]++; }
$6 ~ /,\<padrinhos?\>\./                       { alC["padrinho"]++; }
$6 ~ /,\<pai\>\./                              { alC["pai"]++; }
$6 ~ /,\<primas?\>([ ]+[mp]atern[oa]s?)?\./    { alC["prima"]++; }
$6 ~ /,\<primos?\>([ ]+[mp]atern[oa]s?)?\./    { alC["primo"]++; }
$6 ~ /,\<sobrinhas?\>([ ]+[mp]atern[oa]s?)?\./ { alC["sobrinha"]++; }
$6 ~ /,\<sobrinhos?\>([ ]+[mp]atern[oa]s?)?\./ { alC["sobrinho"]++; }
$6 ~ /,\<tias?\>([ ]+[mp]atern[oa]s?)?\./      { alC["tia"]++; }
$6 ~ /,\<tios?\>([ ]+[mp]atern[oa]s?)?\./      { alC["tio"]++; }

function alineaA (outf)
{
    printf "Frequencia de processos por ano:\n" > outf;
    for (ano in alA)
        printf("%s\t%s\n", ano, alA[ano]) >> outf;
}

function alineaB (outf)
{
    printf "Frequencia de nomes:\n" > outf;
    for (nome in alB)
        printf("%s\t%s\n", nome, alB[nome]) >> outf;
}

function alineaC (outf)
{
    printf "Frequencia dos varios tipos de relacao:\n" > outf;
    for (parentesco in alC)
        printf("%s\t%s\n", parentesco, alC[parentesco]) >> outf;
}

END {
    alineaA("anos.txt");
    alineaB("nomes.txt");
    alineaC("parentescos.txt");
}

\end{verbatim}


\end{document} 
