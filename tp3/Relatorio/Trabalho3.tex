%
% Layout retirado de http://www.di.uminho.pt/~prh/curplc09.html#notas
%
\documentclass{report}
\usepackage[portuges]{babel}
%\usepackage[utf8]{inputenc}
\usepackage[latin1]{inputenc}
\usepackage{url}
\usepackage{enumerate}

\usepackage{float} %package para introduzir a figura exactamente onde queremos no doc
\usepackage{graphicx} %package para utilizar imagens em latex
\graphicspath{ {images/} } %folder onde tem as imagens
\usepackage{wrapfig}
\usepackage{verbatim}
\usepackage{ tipa }
\usepackage{ textcomp }


%\usepackage{alltt}
%\usepackage{fancyvrb}
\usepackage{listings}
%LISTING - GENERAL

\lstset{
	language=C,
	basicstyle=\small,
	numbers=none,
	numberstyle=\tiny,
	numbersep=5pt,
	breaklines=true,
    frame=none,
	mathescape=true,
	escapeinside={(*@}{@*)}
}

%
%\lstset{ %
%	language=Java,							% choose the language of the code
%	basicstyle=\ttfamily\footnotesize,		% the size of the fonts that are used for the code
%	keywordstyle=\bfseries,					% set the keyword style
%	%numbers=left,							% where to put the line-numbers
%	numberstyle=\scriptsize,				% the size of the fonts that are used for the line-numbers
%	stepnumber=2,							% the step between two line-numbers. If it's 1 each line
%											% will be numbered
%	numbersep=5pt,							% how far the line-numbers are from the code
%	backgroundcolor=\color{white},			% choose the background color. You must add \usepackage{color}
%	showspaces=false,						% show spaces adding particular underscores
%	showstringspaces=false,					% underline spaces within strings
%	showtabs=false,							% show tabs within strings adding particular underscores
%	frame=none,								% adds a frame around the code
%	%abovecaptionskip=-.8em,
%	%belowcaptionskip=.7em,
%	tabsize=2,								% sets default tabsize to 2 spaces
%	captionpos=b,							% sets the caption-position to bottom
%	breaklines=true,						% sets automatic line breaking
%	breakatwhitespace=false,				% sets if automatic breaks should only happen at whitespace
%	title=\lstname,							% show the filename of files included with \lstinputlisting;
%											% also try caption instead of title
%	escapeinside={\%*}{*)},					% if you want to add a comment within your code
%	morekeywords={*,...}					% if you want to add more keywords to the set
%}

\usepackage{xspace}

\parindent=0pt
\parskip=2pt

\setlength{\oddsidemargin}{-1cm}
\setlength{\textwidth}{18cm}
\setlength{\headsep}{-1cm}
\setlength{\textheight}{23cm}



\def\LS{\textbf{\emph{LS}}}


%%%%\input{LPgeneralDefintions}

\title{Processamento de Linguagens e Compiladores\\\textbf{Gerador de Processadores de Linguagens Yacc}\\ Relatório de Desenvolvimento\\ Grupo 14}
\author{André Sá (76361) \and João Bastos (47419) \and Pedro Sá (78164)}
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
Este relatório debruça-se sobre o desenvolvimento de uma linguagem imperativa que com o auxilio do Yacc\footnote{Yacc - Gerador de Processadores de Linguagens} gera código Assembly, sendo esse código executável em uma Máquina Virtual(VM)\footnote{Máquina Virtual que mostra o estado das várias stack's ao longo da execução do código gerado pelo Yacc em Assembly} fornecida pelo professor desta Unidade Curricular.
\end{abstract}

\tableofcontents

\chapter{Introdução} \label{intro}
Este relaório debruça-se sobre o desenvolvimento de uma linguagem imperativa que com o auxilio do Yacc\footnote{Yacc - Gerador de Processadores de Linguagens} gera código Assenbly, sendo esse código executável em uma Máquina Virtual(VM)\footnote{Maquina Virtual que mostra o estado das várias stack's ao longo da execução do código gerado pelo Yacc em Assembly} fornecida pelo professor desta Unidade Curricular. 
\section{Enquadramento}
No âmbito da Unidade Curricular Processamento de Linguagens e Compiladores, o projecto proposto consiste na criação de uma Linguagem de Programação Imperativa que permita declarar variáveis atómicas dos tipos Inteiro, Real e Booleano e fazer as operações de atribuição de expressões a variáveis declaradas, leitura (de inteiros ou reais), escrita (de inteiros, reais, booleanos ou strings), condições e ciclos repetir....até 
e gerar código Assembly para a VM fornecida pelo professor.


\section{Estrutura do Relatório}
Neste relatório começamos com a Introdução (Capítulo 1) onde, de uma forma breve descrevemos o enquadramento do documento e a estrutura do mesmo. \\
No capítulo 2 analisamos o problema que nos foi proposto de forma mais detalhada.\\
No capítulo 3 explicamos a linguagem imperativa desenvolvida.\\
No capítulo 4 está representada a gramática da linguagem imperativa desenvolv\\
O capítulo 5 descreverá a conpecpção do analisador sintático.\\
Por último o documento tem o apêndice onde foi introduzido o código fonte do ficheiro Yacc.


\chapter{Análise e Especificação}
\section{Descrição informal do problema}


Este projecto tem como objectivo o aprofundamento de conhecimento Yacc (um gerador de processadores de linguagens). Para tal, foi-nos proposto construir uma linguagem imperativa e gerar um compilador que transforma a sintaxe da linguagem para "Assembly"  reconhecido pela máquina virtual fornecida pelo professor da Unidade Curricular.

\section{Especificação dos Requisitos\label{esp}}


A linguagem a criar deverá permitir declarar Variáveis atómicas dos tipos Inteiro, Real e Booleano e fazer Operações de Atribuição de Expressões a Variáveis declaradas, Leitura (de Inteiros ou Reais), Escrita (de Inteiros, Reais, Booleanos ou Strings), condições e ciclos repetir .. até.
Após definir a linguagem deveremos a partir de um código fonte com essa linguagem transformar em código Assembly da Máquina Virtual fornecida para o efeito.


\chapter{Linguagem Imperativa}
Neste capítulo explicaremos a linguagem imperativa definida e a sua sintaxe.

\section{Variáveis}
As variáveis terão de começar obrigatoriamente por uma letra ou underscore, podendo ser seguida de números, letras ou underscores. A título de exemplo, as variáveis \emph{\_aluno}, \emph{Aluno22}, \emph{aluno} e \emph{aluNo} são válidas.

\section{Tipos}
Apresentamos os tipos aceites na linguagem criada.\\

\begin{tabular}{r l l}
\textbf{Tipo} & \textbf{Descrição} & \textbf{Exemplos} \\
\hline
\textbf{Int} & Inteiro & 1 -22 35 \\
\textbf{Float} & Reais & 1.333 3.0E10 \\
\textbf{Bool} & Booleano & True False \\
\end{tabular}

\section{Operadores}
Os operadores dividem-se em 3 tipos: aritméticos, relacionais e lógicos. De seguida apresentamos os operadores utilizados e a correspondente descrição.
\\

\begin{tabular}[t]{p{30mm} c c l}
\textbf{ARITMÉTICOS} & & \textbf{Operador} & \textbf{Descrição} \\  \cline{3-4}
 &  & \textbf{+} & Soma \\
 &  & \textbf{-} & Subtração \\
 &  & \textbf{*} & Multiplicação\\
 &  & \textbf{/} & Divisão \\
 &  & \textbf{\%} & Resto da divisão inteira \\
\end{tabular}

\mbox{}\\

\begin{tabular}[t]{p{30mm} c c l}
\textbf{RELACIONAIS} & & \textbf{Operador} & \textbf{Descrição}\\ \cline{3-4}
 &  & \textbf{\textless} & Menor \\
 &  & \textbf{\textgreater} & Maior \\
 &  & \textbf{=} & Igual \\
 &  & \textbf{\textless=} & Menor ou igual \\
 &  & \textbf{\textgreater=} & Maior ou igual \\
 &  & \textbf{!=} & Diferente \\
\end{tabular}

\mbox{}\\

\begin{tabular}[t]{p{30mm} c c l}
\textbf{LÓGICOS} & & \textbf{Operador} & \textbf{Descrição}\\ \cline{3-4}
 &  & \textbf{\&} & E lógico \\
 &  & \textbf{\textpipe} & OU lógico \\
 &  & \textbf{\texttildelow} & Negação\\
\end{tabular}


\section{Declaração de Variáveis}
A declaração de variáveis tem a seguinte sintaxe:\\

\fbox{\textbf{(:} tipo var\textbf{)} }\\

Ao declarar, as variáveis são iniciadas com o valor pré-definido do tipo em questão:\\
 
\begin{tabular}{r l}
\textbf{Tipo} & \textbf{Default} \\
\hline
\textbf{Int} & 0\\
\textbf{Float} & 0.0 \\
\textbf{Bool} & False \\
\end{tabular}\\\\

No entanto também é possível definir no momento um \emph{default} diferente iniciando-a com o valor, do tipo da variável, definido. Nestes casos utilizamos a seguinte sintaxe:\\

\fbox{\textbf{(:} tipo var default\textbf{)}}\\

Só é permitido declarar variáveis (\emph{var}) do \emph{tipo} Int, Float e Bool.\\

\section{Atribuições}
Na atribuição a variáveis (\emph{var}) temos a sintaxe seguinte:\\

\fbox{\textbf{(=} var exp \textbf{)}}\\
\\
Em que \emph{exp} pode ser um valor Int, Float, Bool, uma variável ou uma operação aritmética.\\

Podemos também incrementar numa unidade o valor da variável (\emph{var}), que apenas é válido para variáveis do tipo Int e Float:\\

\fbox{\textbf{(++} var\textbf{)}}\\



\section{Condição If}

As condições \emph{if then else} terão a seguinte sintaxe:\\

\fbox{\textbf{(if} exp \textbf{(}code\_block\textbf{) [ (}else\_code\_block\textbf{) ] )}} \\

Em que \emph{exp} terá expressões com valor lógico que corresponderá à condição necessária para executar a porção de código \emph{code\_block}, caso contrário, se definido, será executada a porção de código \emph{else\_code\_block}.

\section{Ciclos}

Os ciclos executam uma determinada porção de código \emph{code\_block} até a condição \emph{exp} ser verdadeira. Nesse sentido, \emph{exp} será uma expressão com valor lógico. Cada ciclo terá então a seguinte sintaxe:\\

\fbox{\textbf{(until} exp \textbf{(}code\_block\textbf{) )}} \\

\section{Leitura}

A leitura será feita do stdin e irá guardar na variável \emph{var} que será do tipo Int ou Float. \\
A sintaxe será:\\

\fbox{\textbf{(read} var\textbf{)}}\\

          	  	
\section{Escrita}

A escrita será feita após receber um Int, Float, Bool ou String seguindo a seguinte sintaxe:\\

\fbox{\textbf{(write} exp\textbf{)}}\\

\section{Impressão}

A impressão utiliza a seguinte sintaxe imprimindo o argumento que lhe é passado: \\

\fbox{\textbf{(print} texto\textbf{)}}\\

\chapter{Gramática}

Seguindo a definição da linguagem descrita no Capítulo 3 criamos a seguinte gramática que será a base do nosso projecto. A partir dela, posteriormente, aplicaremos as respectivas ações semânticas como veremos a seguir.\\ 
\lstinputlisting{./Cod/gramatica.txt}	


\chapter{Concepção/desenho da Resolução}
Neste capítulo iremos descrever a concepção/desenho do analisador sintático indicando a produção em questão e uma breve explicação da respectiva ação semântica.

\subsubsection{programa : code\_block}
Nesta produção são impressas as declarações de variáveis locais, a instrução START para iniciar o programa, o código do programa em si e, finalmente, a instrução STOP que marca o fim do programa.\\


\subsubsection{code\_block : statements}
O código do bloco de código vai ser o código de um statement.\\

\subsubsection{code\_block : statements code\_block}
O código do bloco de código vai ser o resultado de concatenar o código de um statement com o código do resto do block. \\
    
\subsubsection{statements : '(' statement ')'}
O código de um statement vai ser o código do conteúdo desse statement.\\

\subsubsection{statement : ':' TYPE VAR DEFAULT}
Esta produção declara uma variável do tipo TYPE, um nome do tipo VAR e, opcionalmente, um valor DEFAULT. Este default, se existir, tem de ser compatível com o tipo da variável a ser declarada.
Em primeiro lugar, verifica-se que o tipo do valor DEFAULT é compatível com o da variável a declarar. Este não pode ser TYPE\_ERROR, e, se não for TYPE\_DEFAULT (i.e., não for dado nenhum valor default), verificam-se os tipos.
De seguida tenta-se adicionar a variável a uma tabela que contém todas as variáveis declaradas até agora. É um erro declarar uma variável duas vezes, tenham ou não tipos diferentes.
Caso esta operação tenha sucedido, o código deste statement passa a ser o código gerado pelo DEFAULT e, se existir DEFAULT, acrescentamos a instrução de STORE para guardar o valor na variável.

\subsubsection{statement : INC VAR}
Esta produção é equivalente a (= VAR (+ VAR 1)).

\subsubsection{statement : '=' VAR expression}
Nesta produção verificamos se VAR foi declarada e se os tipos da variável e da expressão são compatíveis. Se forem, o código resultante será o de apender a instrução STORE ao código da expressão.

\subsubsection{statement : WRITE writable}
Nesta produção geramos código para escrever o valor de um writable. Writable pode ser tanto uma expressão como uma string literal.

\subsubsection{statement : PRINT writable}
Esta produção faz o mesmo que o WRITE, mas escreve também um caracter de mudanca de linha.

\subsubsection{statement : READ VAR}
Esta produção de um valor do stdin e guarda-o na variável VAR.
É um erro se a variável não tiver sido declarada, e não for dos tipos Int ou Float.
As instruções geradas são, por ordem, READ, ATO[IF], STORE.

\subsubsection{statement : IF expression2 '(' code\_block ')' else\_clause}
Nesta produção geramos um identificador único para as labels necessárias (ELSE e ENDIF). O código final será:
        <codigo gerado pela expressão de condição>
        JZ ELSE
        <codigo gerado pelo bloco then>
        JUMP ENDIF
        ELSE:
        <codigo gerado pelo block else>
        ENDIF:

\subsubsection{statement : UNTIL expression2 '(' code\_block ')'}
Nesta produção geramos um identificador único para a label necessária (UNTIL). O código final será:
        UNTIL:
        <codigo gerado pelo bloco do ciclo>
        <codigo gerado pela expressao de condicao>
        JZ UNTIL

\subsubsection{writable : expression}
O código de algo que pode ser escrito e o código da expressão.

\subsubsection{writable : STR}
Nesta produção é simplemente gerada a instrução PUSHS com a string devolvida pelo Flex.

\subsubsection{DEFAULT : }
Nesta produção não é gerado nenhum código. O tipo desta produção é TYPE\_DEFAULT, para distinguir os casos em que existe valor default dos casos em que não existe.

\subsubsection{DEFAULT : expression}
O valor de default vai ser o computado na expressão.

\subsubsection{else\_clause : }
Nesta produção não é gerado nenhum código.

\subsubsection{else\_clause : '(' code\_block ')'}
Nesta produção o código dá else clause e o código gerado para o bloco de código.

\subsubsection{expression : VALUE}
Nesta produção gera-se a instrução de PUSH com o valor lido pelo Flex.

\subsubsection{expression : expression2}
O código resultante é o código gerado pela expression2.

\subsubsection{expression : '(' expression\_list ')'}
O código resultante é o código gerado pela expression\_list.

\subsubsection{VALUE : INT\_VALUE }
O tipo desta produção é o tipo Int.
   
\subsubsection{VALUE :FLOAT\_VALUE}
O tipo desta produção é o tipo Float.

\subsubsection{expression\_list : arith\_op expression expression}
O código resultante desta produção e o de concatenar o código da primeira expressão com o da segunda e depois a instrução correspondente a operação.
Esta produção corresponde a operações aritmética sobre valores numéricos. É um erro se os tipos não forem compatíveis.
              
\subsubsection{expression2 : VAR}
Nesta produção gera-se a instrução de carregar o endereço da variável e a de carregar o valor nesse endereço.
   
\subsubsection{expression2 : BOOL\_VALUE}
Nesta produção gera-se a instrução de por na stack o valor booleano lido pelo Flex.

\subsubsection{exoression2 : '(' expression2\_list ')'} 
O código resultante e o código gerado pela expression2\_list.

\subsubsection{expression2\_list : '~' expression2}
O código resultante desta produção e o de concatenar a instrução NOT ao código da expression2.
               
\subsubsection{expression2\_list : num\_op expression expression}        
O código resultante desta produção e o de concatenar o código da primeira expressão com o da segunda e a instrução correspondente a operação.
Esta produção corresponde à comparação de valores numéricos. É um erro se os tipos das duas expressões não forem compatíveis.

\subsubsection{expression2\_list : log\_op expression2 expression2}
O código resultante desta produção e o de concatenar o código da primeira expressão com o da segunda e a instrução correspondente a operação.
Esta produção corresponde a operações lógicas sobre valores booleanos.







\chapter{Testes}
\section{Testes realizados e Resultados}

Para efeitos de teste preparamos vários ficheiros que cada um contém desde declarações, a atribuições, condições, ciclos, etc...\\
Estes testes serão organizados em tabelas abaixo apresentadas com a primeira coluna a representar o código-fonte de acordo com a nossa linguagem imperativa criada e a segunda coluna com o código em "assembly" em conformidade com a máquina virtual fornecioda.
\subsection{Declarações e Atribuições}
\begin{tabular}{ | c |c|}
\hline
Input & Output \\
\hline
\lstinputlisting{../examples/atribs.z}
 & \lstinputlisting{../examples/atribs.vm} \\
 \hline
\end{tabular}

\subsection{Operadores Aritméticos}
\begin{tabular}{| c |c|}
\hline
Input & Output \\
\hline

\lstinputlisting{../examples/arith.z}
& \lstinputlisting{../examples/arith.vm} \\
\hline
\end{tabular}

\subsection{Leitura}
\begin{tabular}{| c |c|}
\hline
Input & Output \\
\hline
\lstinputlisting{../examples/read_float.z}
 & \lstinputlisting{../examples/read_float.vm}\\
\hline
\end{tabular}


\subsection{Condição IF}
\begin{tabular}{| c |c|}
\hline
Input & Output \\
\hline
\lstinputlisting{../examples/if.z}
 & \lstinputlisting{../examples/if.vm}\\
\hline
\end{tabular}

\subsection{Ciclo Repetir..Até }
\begin{tabular}{| c |c|}
\hline
Input & Output \\
\hline
\lstinputlisting{../examples/until.z}
 & \lstinputlisting{../examples/until.vm}\\
\hline
\end{tabular}


   
\chapter{Conclusão} \label{concl}

Este projecto mostrou-nos que tendo já desenvolvido a gramática de uma linguagem imperativa, podemos criar um compilador através do Yacc que usando a estrutura 'Produção-Ação', isto é, para cada instrução do código fonte que satisfaça alguma produção da linguagem imperativa tem como ação a criação do código "assembly", o que consequentemente, deu-nos uma visão mais detalhada sobre como um compilador funciona.
Este projeto está finalizado para o que nos foi proposto.

\appendix
\chapter{Código do Programa}

Lista-se a seguir o código Yacc do programa que foi desenvolvido.
\begin{verbatim}
%{
#include <stdbool.h>
#include <stdio.h>

#include "env.h"
#include "gen.h"
#include "str.h"
#include "rope.h"

#include "lex.yy.h"

int yyerror (const char *s);

/**
 * Verifica se uma condicao e verdadeira e, caso nao seja,
 * imprime uma mensagem de erro e aborta o programa
 */
#define assert(cond, ...)                       \
    if (!(cond)) do {                           \
        fprintf(stderr, "ERROR: " __VA_ARGS__); \
        return 1;                               \
    } while (0)

/** Se activado, mostra as producoes por onde passa */
#ifdef TRACE
#define trace(...) ((void) fprintf(stderr, "TRACE: %s:%d\n", __FILE__, __LINE__))
#else
#define trace(...) ((void) 0)
#endif /* TRACE */

#define type_valid(t)       ((t) > TYPE_ERROR && (t) < TYPE_DEFAULT)
#define type_compat(t1, t2) ((t1) == (t2))

/**
 * Concatena dois blocos de codigo, @a self e @a other, e imprime
 * uma mensagem em caso de erro
 */
#define cbapp(self, other) do {                \
        assert(rope_append(&(self), &(other)), \
            "appending code blocks: %s:%d\n",  \
            __FILE__, __LINE__);               \
        (other) = rope_free(other);            \
    } while (0)

/**
 * Gera wrappers para funcoes geradoras de codigo que imprimem
 * uma mensagem em caso de erro
 */
#define gen_(f, ...)               \
    assert((gen_##f)(__VA_ARGS__), \
        #f "(): %s:%d\n",          \
        __FILE__, __LINE__)

#define gen_jump(  c, l, n)    gen_(jump,   (c), (l), (n))
#define gen_jz(    c, l, n)    gen_(jz,     (c), (l), (n))
#define gen_nlbl(  c, l, n)    gen_(nlbl,   (c), (l), (n))
#define gen_load(  c, i)       gen_(load,   (c), (i))
#define gen_op(    c, o, t)    gen_(op,     (c), (o), (t))
#define gen_push(  c, t, a, b) gen_(push,   (c), (t), (a), (b))
#define gen_pushgp(c)          gen_(pushgp, (c))
#define gen_storeg(c, i)       gen_(storeg, (c), (i))

static struct rope _var_decs = {0};
static struct rope * const var_decs = &_var_decs;

%}

%union {
    struct expr {
        enum type   type;
        struct rope code;
    }           valExpr;

    bool        valBool;
    char *      valString;
    enum type   valType;
    float       valFloat;
    int         valInt;
    struct rope valCode;
}

%token INC
%token GEQ
%token IF
%token LEQ
%token NEQ
%token PRINT
%token READ
%token UNTIL
%token WRITE

%token <valBool>  BOOL_VALUE
%token <valFloat> FLOAT_VALUE
%token <valInt>   INT_VALUE
%token <valString>STR
%token <valString>VAR
%token <valType>  TYPE

%type <valCode>code_block
%type <valCode>else_clause
%type <valCode>statement
%type <valCode>statements

%type <valExpr>DEFAULT
%type <valExpr>expression
%type <valExpr>expression2
%type <valExpr>expression2_list
%type <valExpr>expression_list
%type <valExpr>writable

%type <valInt>arith_op
%type <valInt>log_op
%type <valInt>num_op

%type <valType>VALUE

%%

programa : code_block { trace();
             rope_fprint(var_decs, yyout);
             fputs("START\n", yyout);
             rope_fprint(&$1, yyout);
             fputs("STOP\n", yyout);
             $1 = rope_free($1);
         }
         ;

code_block : statements            { trace(); $$ = $1; }
           | statements code_block { trace();
               $$ = $1;
               cbapp($$, $2);
           }
           ;

statements : '(' statement ')' { trace(); $$ = $2; }
           ;

statement : ':' TYPE VAR DEFAULT { trace();
              assert($4.type != TYPE_ERROR
                  && (!type_valid($4.type) || type_compat($2, $4.type)),
                  "%s:%s but default value is of type %s\n",
                  $3, type2str($2), type2str($4.type));

              struct var var = { .id = $3, .type = $2, };
              assert(env_new_var(env, var), "creating variable `%s`\n", $3);

              $$ = $4.code;
              if (!rope_is_empty(&$$))
                  gen_storeg(&$$, env_var_gp_idx(env, $3));

              gen_push(var_decs, $2,
                  (($2 == TYPE_FLOAT) ? "0.0" : "0"),
                  yylval.valBool);
          }
          | INC VAR { trace();
              $$ = (struct rope) {0};
              struct var * v = env_var(env, $2);
              enum type t = env_typeof(env, $2);
              unsigned gidx = env_var_gp_idx(env, $2);

              assert(v != NULL, "Variable not found: `%s`\n", $2);

              assert(t == TYPE_INT || t == TYPE_FLOAT,
                  "type: Expected Int or Float but got %s\n",
                  type2str(t));

              const char * arg = (t == TYPE_INT) ? "1" : "1.0";

              gen_pushgp(&$$);
              gen_load(&$$, gidx);
              gen_push(&$$, t, arg, false);
              gen_op(&$$, '+', t);
              gen_storeg(&$$, gidx);
          }
          | '=' VAR expression { trace();
              struct var * v = env_var(env, $2);
              assert(v != NULL, "Variable not found: `%s`\n", $2);
              $$ = $3.code;
              gen_storeg(&$$, env_var_gp_idx(env, $2));
          }
          | WRITE writable { trace();
              $$ = $2.code;
              gen_op(&$$, WRITE, $2.type);
          }
          | PRINT writable { trace();
              $$ = $2.code;
              gen_op(&$$, WRITE, $2.type);
              gen_push(&$$, TYPE_STRING, "\"\\n\"", false);
              gen_op(&$$, WRITE, TYPE_STRING);
          }
          | READ VAR { trace();
              $$ = (struct rope) {0};
              struct var * v = env_var(env, $2);
              assert(v != NULL, "Variable not found: `%s`\n", $2);

              assert(v->type == TYPE_INT || v->type == TYPE_FLOAT,
                  "`read`: Expected Int or Float but got %s\n",
                  type2str(v->type));

              gen_read(&$$);
              gen_aton(&$$, v->type);
              gen_storeg(&$$, env_var_gp_idx(env, $2));
          }
          | IF expression2 '(' code_block ')' else_clause { trace();
              unsigned num = gen_ifno();

              $$ = $2.code;
              gen_jz(&$$, "ELSE", num);    /* jump to else label? */
              cbapp($$, $4);               /* then block */
              gen_jump(&$$, "ENDIF", num); /* jump to endif label */
              gen_nlbl(&$$, "ELSE", num);  /* else label */
              cbapp($$, $6);               /* else block (possibly empty) */
              gen_nlbl(&$$, "ENDIF", num); /* endif label */
          }
          | UNTIL expression2 '(' code_block ')' { trace();
              $$ = (struct rope) {0};
              unsigned num = gen_untilno();

              gen_nlbl(&$$, "UNTIL", num); /* until label */
              cbapp($$, $4);               /* loop body block */
              cbapp($$, $2.code);          /* condition */
              gen_jz(&$$, "UNTIL", num);   /* jump to until label? */
          }
          ;

writable : expression { trace(); $$ = $1; }
         | STR        { trace();
             $$ = (struct expr) {0};
             $$.type = TYPE_STRING;
             gen_push(&$$.code, TYPE_STRING, yytext, false);
         }
         ;

DEFAULT : { trace();
            $$ = (struct expr) {0};
            $$.type = TYPE_DEFAULT;
        }
        | expression { trace(); $$ = $1; }
        ;

else_clause :                    { trace(); $$ = (struct rope) {0}; }
            | '(' code_block ')' { trace(); $$ = $2; }
            ;

expression : VALUE { trace();
               $$ = (struct expr) {0};
               $$.type = $1;
               gen_push(&$$.code, $1, yytext, false);
           }
           | expression2             { trace(); $$ = $1; }
           | '(' expression_list ')' { trace(); $$ = $2; }
           ;

VALUE : INT_VALUE   { trace(); $$ = TYPE_INT;   }
      | FLOAT_VALUE { trace(); $$ = TYPE_FLOAT; }
      ;

arith_op : '+' { trace(); $$ = '+'; }
         | '*' { trace(); $$ = '*'; }
         | '-' { trace(); $$ = '-'; }
         | '/' { trace(); $$ = '/'; }
         | '%' { trace(); $$ = '%'; }
         ;

expression_list : arith_op expression expression { trace();
                    $$ = (struct expr) {0};
                    enum type t1 = $2.type;
                    enum type t2 = $3.type;
                    assert(type_valid(t1) && type_valid(t2) && type_compat(t1, t2),
                        "`%c`: Types don't match: op1:%s and op2:%s\n",
                        $1, type2str(t1), type2str(t2));
                    $$.type = t1;

                    assert($$.type != TYPE_FLOAT || $1 != '%',
                        "`%%`: Expected Int, got %s\n",
                        type2str($$.type));

                    $$.code = $2.code;
                    cbapp($$.code, $3.code);
                    gen_op(&$$.code, $1, t1);
                }
                ;

expression2 : VAR { trace();
                $$ = (struct expr) {0};
                $$.type = env_typeof(env, $1);
                assert(type_valid($$.type), "Variable not found: `%s`\n", $1);

                gen_pushgp(&$$.code);
                gen_load(&$$.code, env_var_gp_idx(env, $1));
            }
            | BOOL_VALUE { trace();
                $$ = (struct expr) {0};
                $$.type = TYPE_BOOL;
                gen_push(&$$.code, TYPE_BOOL, NULL, yylval.valBool);
            }
            | '(' expression2_list ')' { trace(); $$ = $2; }
            ;

num_op : '<' { trace(); $$ = '<'; }
       | '=' { trace(); $$ = '='; }
       | '>' { trace(); $$ = '>'; }
       | GEQ { trace(); $$ = GEQ; }
       | LEQ { trace(); $$ = LEQ; }
       | NEQ { trace(); $$ = NEQ; }
       ;

log_op : '&' { trace(); $$ = '&'; }
       | '|' { trace(); $$ = '|'; }
       ;

expression2_list : '~' expression2 { trace();
                     $$ = (struct expr) {0};
                     enum type t = $2.type;
                     assert(t == TYPE_BOOL, "`~`: Expected Bool, got %s\n", type2str(t));
                     $$.type = t;

                     $$.code = $2.code;

                     gen_op(&$$.code, '~', $2.type);
                 }
                 | num_op expression expression { trace();
                     $$ = (struct expr) {0};
                     enum type t1 = $2.type;
                     enum type t2 = $3.type;
                     assert(type_valid(t1) && type_valid(t2) && type_compat(t1, t2),
                         "`%c`: Types don't match: op1:%s and op2:%s\n",
                         $1, type2str(t1), type2str(t2));
                     $$.type = TYPE_BOOL;

                     $$.code = $2.code;
                     cbapp($$.code, $3.code);
                     gen_op(&$$.code, $1, t1);
                 }
                 | log_op expression2 expression2 { trace();
                     enum type t1 = $2.type;
                     enum type t2 = $3.type;
                     assert(t1 == TYPE_BOOL && t2 == TYPE_BOOL,
                         "`%c`: Expected Bool, got op1:%s and op2:%s\n",
                         $1, type2str(t1), type2str(t2));

                     $$ = $2;

                     cbapp($$.code, $3.code);
                     gen_op(&$$.code, $1, t1);
                 }
                 ;

%%

int yyerror (const char *s)
{
  return fprintf(stderr, "ERRO: '%s'\n", s);
}
\end{verbatim}

\end{document} 
