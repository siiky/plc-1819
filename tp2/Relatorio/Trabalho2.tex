%
% Layout retirado de http://www.di.uminho.pt/~prh/curplc09.html#notas
%
\documentclass{report}
\usepackage[portuges]{babel}
%\usepackage[utf8]{inputenc}
\usepackage[latin1]{inputenc}
\usepackage{url}
\usepackage{enumerate}

\usepackage{float} %package para introduzir a figura exactamente onde queremos no doc
\usepackage{graphicx} %package para utilizar imagens em latex
\graphicspath{ {images/} } %folder onde tem as imagens
\usepackage{wrapfig}


%\usepackage{alltt}
%\usepackage{fancyvrb}
\usepackage{listings}
%LISTING - GENERAL
\lstset{
	language=Awk,
	basicstyle=\small,
	numbers=left,
	numberstyle=\tiny,
	numbersep=5pt,
	breaklines=true,
    frame=tB,
	mathescape=true,
	escapeinside={(*@}{@*)}
}

%
%\lstset{ %
%	language=Java,							% choose the language of the code
%	basicstyle=\ttfamily\footnotesize,		% the size of the fonts that are used for the code
%	keywordstyle=\bfseries,					% set the keyword style
%	%numbers=left,							% where to put the line-numbers
%	numberstyle=\scriptsize,				% the size of the fonts that are used for the line-numbers
%	stepnumber=2,							% the step between two line-numbers. If it's 1 each line
%											% will be numbered
%	numbersep=5pt,							% how far the line-numbers are from the code
%	backgroundcolor=\color{white},			% choose the background color. You must add \usepackage{color}
%	showspaces=false,						% show spaces adding particular underscores
%	showstringspaces=false,					% underline spaces within strings
%	showtabs=false,							% show tabs within strings adding particular underscores
%	frame=none,								% adds a frame around the code
%	%abovecaptionskip=-.8em,
%	%belowcaptionskip=.7em,
%	tabsize=2,								% sets default tabsize to 2 spaces
%	captionpos=b,							% sets the caption-position to bottom
%	breaklines=true,						% sets automatic line breaking
%	breakatwhitespace=false,				% sets if automatic breaks should only happen at whitespace
%	title=\lstname,							% show the filename of files included with \lstinputlisting;
%											% also try caption instead of title
%	escapeinside={\%*}{*)},					% if you want to add a comment within your code
%	morekeywords={*,...}					% if you want to add more keywords to the set
%}

\usepackage{xspace}

\parindent=0pt
\parskip=2pt

\setlength{\oddsidemargin}{-1cm}
\setlength{\textwidth}{18cm}
\setlength{\headsep}{-1cm}
\setlength{\textheight}{23cm}



\def\LS{\textbf{\emph{LS}}}


%%%%\input{LPgeneralDefintions}

\title{Processamento de Linguagens e Compiladores\\\textbf{Processador de Róis de Confessados}\\ Relatório de Desenvolvimento\\ Grupo 14}
\author{André Sá (76361) \and João Bastos (47419) \and Pedro Sá (78164)}
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
Este projecto consiste na criação de um processador de texto que a partir de Róis de Confessados disponibilizados calcula a frequência de vários padrões. No decorrer deste relatório iremos demonstrar a nossa análise e abordagem ao problema, bem como a codificação acompanhada de uma breve explicação.
\end{abstract}

\tableofcontents

\chapter{Introdução} \label{intro}
\section{Enquadramento}
Os róis de confessados eram listas nominativas elaboradas durante a quaresma a fim de constatar quais fiéis se confessaram e comungaram no último ano. Este texto determinava que nos róis constassem os nomes de todos os paroquianos, estado matrimonial, se eram crismados, se eram menores de idade, entre outras informações consideradas relevantes. Os róis de confessados deveriam listar os fregueses de cada domicílio, separando as informações com uma linha. O processador texto que iremos criar será implementado sobre um exemplo de rol de confessados.

\section{Estrutura do Relatório}
Neste relatório começamos com a Introdução (Capítulo 1) onde, de uma forma breve tentamos descrever o enquadramento do documento e a estrutura do mesmo. \\
No capítulo 2 analisamos o texto a processar e o problema que nos foi proposto de forma mais detalhada bem como uma introdução da nossa abordagem ao mesmo.\\
No capítulo 3 indicamos a estrutura de dados utilizada e explicamos o código por nós criado.\\
No capítulo 4 apresentamos alguns testes realizados e o respectivo output.\\
O capítulo 5 é composto pela conclusão, onde fazemos uma análise ao projecto executado.\\
Por último o documento tem o apêndice onde foi introduzido o código fonte do ficheiro Gawk.


\chapter{Análise e Especificação}
\section{Descrição informal do problema}

Este projecto tem como objectivo o aprofundamento de conhecimento do Sistema de Produção\footnote{Sistema baseado num conjunto de regras 'Condição-Acção'.} AWK (uma lingagem de programação para a deteção de padrões e processamento de texto, mais o respetivo interpretador). Para tal, foi-nos proposto construir um ficheiro Gawk\footnote{Gawk - GNU AWK (A palavra AWK é uma abreviatura das iniciais dos sobrenomes dos criadores da linguagem (Aho, Weinberger e Kernighan).} para processar um rol de confessados, com o intuito de calcular o número de certas ocorrências.\\
Na próxima secção indicaremos com mais detalhe as ocorrências pretendidas e de que forma pretendemos resolver tais problemas.

\section{Especificação dos Requisitos\label{esp}}


O Rol de Confessados que nos foi facultado tem um registo por linha.
Cada campo do registo está separado por "::", sendo que 6 têm o seguinte conteúdo:
\begin{description}
\item[1º campo (\$1)] Número do registo;
\item[2º campo (\$2)] Data do registo;
\item[3º campo (\$3)] Nome do paroquiano a registar;
\item[4º campo (\$4)] Pai do paroquiano;
\item[5º campo (\$5)] Mãe do paroquiano;
\item[6º campo (\$6)] Informação complementar.
\end{description} 
e o último campo apresenta-se sempre vazio.\\\\

Todos os registos têm os primeiros 3 campos preenchidos, podendo os restantes estar omissos.
Apresentemos o exemplo de um registo completo para facilitar na compreensão do exposto acima e nas seguintes referências a registos do Rol de Confessados.\\

\begin{verbatim}
598::1722-07-29::Pedro Jose Sousa::Pedro Sousa Falcao::Mariana Sousa Pereira
::Manuel Felix Sousa,Irmao. Proc.8224.::
\end{verbatim}

.\\
\paragraph{Foi-nos proposto sobre o Rol de Confessados fazermos o seguinte processamento:}


\subsubsection{Alínea a) - Calcular a frequência de processos por ano}
Dentro do 2º campo, que representa a data do registo, teremos de verificar em cada registo o ano indicado e calcular o número de vezes que cada ano aparece.

\subsubsection{Alínea b) - Calcular a frequência de nomes}
Dentro dos campos 3, 4 e 5 teremos de verificar todos os nomes apresentados e contabilizá-los para, após todas as linhas serem processadas, apresentarmos o número de ocorrências de cada nome em todas as linhas do rol.

\subsubsection{Alínea c) - Calcular a frequência dos vários tipo de relação} 
Em alguns registos existe informação sobre os tipos de relação existentes com o paroquiano em questão. Essa informação está presente somente no 6º campo pelo que teremos de verificar as ocorrências dessas relações e contabilizar todas para no final apresentarmos o número de ocorrências de cada relação.




\chapter{Concepção/desenho da Resolução}





\section{Estruturas de Dados}

Um array associativo é uma estrutura de dados - análoga aos dicionários - composta por um conjunto não ordenado de itens formados por um par chave-valor, em que cada chave possui um valor associado. \\
O Gawk permite-nos utilizar strings como índices. Assim, optamos pela utilização de arrays associativos para contar a ocorrência de determinadas strings sendo as strings as chaves e o valor o número de ocorrências de cada uma.

\section{Codificação}

\subsubsection{BEGIN}
Inicialmente especificamos acções a serem executadas antes do processamento da primeira linha utilizando o padrão BEGIN.
\begin{verbatim}
BEGIN   {
            FS="::";
            IGNORECASE=1
        }
\end{verbatim}
Assim definimos o Field Separator (FS) como "::" \ e a detecção de padrões como Case Insensitive.

\subsubsection{Linhas em Branco}
Salvaguardamos o facto do ficheiro ter linhas em branco ignorando as mesmas.
\begin{verbatim}
/^\s*$/	{ next; } 
\end{verbatim}

\subsubsection{Alínea a) - Frequência de processos por ano}
Para calcularmos o número de processos por ano separamos o que está entre '-' no 1º campo e, num array associativo, utilizamos o elemento correspondente ao ano\footnote{Formato do 1º campo: 1778-01-14. Ter em conta que em Awk os índices dos arrays sendo numéricos começam em 1, que é o índice onde será guardado o ano no array data.} como chave. Se a chave já existe apenas incrementa, caso contrário cria a nova chave e incrementa o valor.
\begin{verbatim}
		{
    			split($2, data, /-/);
    			alA[data[1]]++;
		}
\end{verbatim}

\subsubsection{Alínea b) - Frequência de nomes}
Os nomes que pretendemos vão estar todos entre os campos 3, 4 e 5, que correspondem respectivamente ao paroquiano, o seu pai e a sua mãe. Nos campos indicados estão os nomes completos mas, uma vez que pretendemos contar as ocorrências de cada nome, separamos os vários nomes e apelidos e guardamos num array associativo. Cada nome/apelido será a chave desse array e a cada ocorrência irá incrementar o respectivo valor. Assim, no final do processamento de todas as linhas do texto teremos guardado nesse array todos os nomes/apelidos (chave) e o número de ocorrências de cada um deles (valor).

\begin{verbatim}
{
    for (i = 3; i < 6; i++) {
        # Tirar Expostos/Solteiras/etc
        gsub(/,.*$/, "", $i);

        split($i, nomes, /\s+/);

        for (nome in nomes)
            alB[nomes[nome]]++;
    }
}
\end{verbatim}


\subsubsection{Alínea c) - Frequência dos tipos de relação}
Analisando o rol de confessados que nos foi facultado verificamos que dentro do 6º campo temos informação complementar onde, entre outras informações, surgem os tipos de relação. Portanto procuramos correspondências com os padrões dentro do 6º campo de cada linha.
Verificamos também que cada relação identificada é precedida de uma virgula e termina com o ponto final. Assim, optamos pela procura desse padrão associando a correspondência à chave do array associativo incrementando o seu valor a cada correspondência obtida.


\begin{verbatim}

$6 ~ /,\<avo\>([ ]+[mp]atern[oa]s?)?\./        { alC["avo"]++; }
$6 ~ /,\<irmaos?\>([ ]+[mp]atern[oa]s?)?\./    { alC["irmao"]++; }
$6 ~ /,\<irmas?\>([ ]+[mp]atern[oa]s?)?\./     { alC["irma"]++; }
$6 ~ /,\<mae\>\./                              { alC["mae"]++; }
$6 ~ /,\<madrastas?\>([ ]+[mp]atern[oa]s?)?\./ { alC["madrasta"]++; }
$6 ~ /,\<padrastos?\>([ ]+[mp]atern[oa]s?)?\./ { alC["padrasto"]++; }
$6 ~ /,\<madrinhas?\>([ ]+[mp]atern[oa]s?)?\./ { alC["madrinha"]++; }
$6 ~ /,\<padrinhos?\>([ ]+[mp]atern[oa]s?)?\./ { alC["padrinho"]++; }
$6 ~ /,\<pai\>\./                              { alC["pai"]++; }
$6 ~ /,\<primas?\>([ ]+[mp]atern[oa]s?)?\./    { alC["prima"]++; }
$6 ~ /,\<primos?\>([ ]+[mp]atern[oa]s?)?\./    { alC["primo"]++; }
$6 ~ /,\<sobrinhas?\>([ ]+[mp]atern[oa]s?)?\./ { alC["sobrinha"]++; }
$6 ~ /,\<sobrinhos?\>([ ]+[mp]atern[oa]s?)?\./ { alC["sobrinho"]++; }
$6 ~ /,\<tias?\>([ ]+[mp]atern[oa]s?)?\./      { alC["tia"]++; }
$6 ~ /,\<tios?\>([ ]+[mp]atern[oa]s?)?\./      { alC["tio"]++; }
\end{verbatim}

\subsubsection{Funções}
Definimos 3 funções que irão escrever o conteúdo de cada um dos arrays associativos - cada um no seu ficheiro - de forma formatada e com uma descrição na primeira linha de cada um.
\begin{verbatim}
function alineaA (outf)
{
    printf "Frequência de processos por ano:\n" > outf;
    for (ano in alA)
        printf("%s\t%s\n", ano, alA[ano]) >> outf;
}

function alineaB (outf)
{
    printf "Frequência de nomes:\n" > outf;
    for (nome in alB)
        printf("%s\t%s\n", nome, alB[nome]) >> outf;
}

function alineaC (outf)
{
    printf "Frequência dos vários tipos de relação:\n" > outf;
    for (parentesco in alC)
        printf("%s\t%s\n", parentesco, alC[parentesco]) >> outf;
}
\end{verbatim}
 
 
\subsubsection{END}

Para finalizar utilizamos o END para executarmos as funções acima definidas após todas as linhas terem sido executadas. 

\begin{verbatim}
END     {
          alineaA("anos.txt");
          alineaB("nomes.txt");
          alineaC("parentescos.txt");
        }	
\end{verbatim}
Criando assim os 3 ficheiros com extensão txt que irão armazenar os resultados pedidos para cada uma das alíneas.

\chapter{Testes}
\section{Testes realizados e Resultados}

Devido ao facto do rol de confessados ter bastante informação para ser processada ($\approx 37000\ linhas$), o grupo decidiu para efeitos de apresentação de testes e resultados desse processamento, apresentar neste relatório uma porção do rol de confessados representativa da informação contida nesse rol.\\
Ao processar o rol de confessados verificamos que existem algumas variações na apresentação da informação, isto é, existem registos (linhas do rol de confessados) em que os campos não estavam todos preenchidos, mais especificamente o campo 6. E por vezes, como foi referido na secção \ref{esp}, esse campo contém informação complementar incluindo tipo de relação.\\
Abaixo encontra-se porção supra referida do rol de processos, onde cada linha representa um registo desse rol e contém os campos referidos na secção \ref{esp}.
\\


\lstinputlisting{../teste1.txt} %input de um ficheiro

\subsubsection{Alínea a) - Frequência de processos por ano}
De seguida apresentamos o ficheiro \emph{anos.txt} com o resultado da frequência de processos por ano:\\

\lstinputlisting{../anos.txt} %input de um ficheiro

\subsubsection{Alínea b) - Frequência de nomes}
De seguida apresentamos o ficheiro \emph{nomes.txt} com o resultado da frequência de nomes:\\
\lstinputlisting{../nomes.txt} %input de um ficheiro

\subsubsection{Alínea c) - Frequência dos tipos de relação}
De seguida apresentamos o ficheiro \emph{parentescos.txt} com o resultado da frequência de vários tipos de relação:\\
\lstinputlisting{../parentescos.txt} %input de um ficheiro



\chapter{Conclusão} \label{concl}

Este projecto mostrou-nos que o Gawk permite-nos programar filtros de texto e relatórios sobre informação de forma muito acessível, principalmente quando existe muito informação para ser processada.\\
Este projeto está finalizado para o que nos foi proposto.
Se no futuro houver necessidade de uma filtragem/processamento mais específico apenas teremos de fazer pequenas alterações ou incluir novos padrões baseando-nos na mesma estrutura 'Padrão-Acção' e usando a mesma estrutura de dados (arrays associativos).

\appendix
\chapter{Código do Programa}

Lista-se a seguir o código Awk do programa  que foi desenvolvido.
\begin{verbatim}
BEGIN {
    FS="::";
    IGNORECASE=1
}

/^\s*$/ { next; }

{ # Alinea (a)
    split($2, data, /-/);
    alA[data[1]]++;
}

{ # Alinea (b)
    for (i = 3; i < 6; i++) {
        # Tirar Expostos/Solteiras/etc
        gsub(/,.*$/, "", $i);

        split($i, nomes, /\s+/);

        for (nome in nomes)
            alB[nomes[nome]]++;
    }
}

# Alinea (c)
$6 ~ /,\<avo\>([ ]+[mp]atern[oa]s?)?\./        { alC["avo"]++; }
$6 ~ /,\<irmaos?\>\./                          { alC["irmao"]++; }
$6 ~ /,\<irmas?\>\./                           { alC["irma"]++; }
$6 ~ /,\<mae\>\./                              { alC["mae"]++; }
$6 ~ /,\<madrastas?\>\./                       { alC["madrasta"]++; }
$6 ~ /,\<padrastos?\>\./                       { alC["padrasto"]++; }
$6 ~ /,\<madrinhas?\>\./                       { alC["madrinha"]++; }
$6 ~ /,\<padrinhos?\>\./                       { alC["padrinho"]++; }
$6 ~ /,\<pai\>\./                              { alC["pai"]++; }
$6 ~ /,\<primas?\>([ ]+[mp]atern[oa]s?)?\./    { alC["prima"]++; }
$6 ~ /,\<primos?\>([ ]+[mp]atern[oa]s?)?\./    { alC["primo"]++; }
$6 ~ /,\<sobrinhas?\>([ ]+[mp]atern[oa]s?)?\./ { alC["sobrinha"]++; }
$6 ~ /,\<sobrinhos?\>([ ]+[mp]atern[oa]s?)?\./ { alC["sobrinho"]++; }
$6 ~ /,\<tias?\>([ ]+[mp]atern[oa]s?)?\./      { alC["tia"]++; }
$6 ~ /,\<tios?\>([ ]+[mp]atern[oa]s?)?\./      { alC["tio"]++; }

function alineaA (outf)
{
    printf "Frequencia de processos por ano:\n" > outf;
    for (ano in alA)
        printf("%s\t%s\n", ano, alA[ano]) >> outf;
}

function alineaB (outf)
{
    printf "Frequencia de nomes:\n" > outf;
    for (nome in alB)
        printf("%s\t%s\n", nome, alB[nome]) >> outf;
}

function alineaC (outf)
{
    printf "Frequencia dos varios tipos de relacao:\n" > outf;
    for (parentesco in alC)
        printf("%s\t%s\n", parentesco, alC[parentesco]) >> outf;
}

END {
    alineaA("anos.txt");
    alineaB("nomes.txt");
    alineaC("parentescos.txt");
}

\end{verbatim}


\end{document} 
